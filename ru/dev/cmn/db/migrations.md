---
title: Миграции
---

# Описание

Миграции - это система версионирования структуры базы данных, 
позволяющая описать разницу структуры между двумя состояниями (двумя
релизами приложения) в виде отдельных файлов, описывающих эти изменения.

# Мотивация

При выкладке новых версий приложения необходимо так или иначе обновлять
схему приложения. Самый простой способ - выполнять эти изменения 
вручную, однако у него есть следующие проблемы:

- Он не автоматизируется
- Даже если ведется общий журнал изменений, любые изменения сначала 
тестируются вручную, и присутствует ненулевая вероятность того, что
разработчик забудет внести изменение в журнал, и при выкладке 
приложение сломается (и, что хуже, никто не будет знать причину, что
вызовет непозволительный простой)
- Процесс применения изменений неидемпотентный, и применить только те
изменения, которые не были применены, невозможно без ручной работы по
фильтрации изменений
- Сам по себе процесс применения изменений занимает рабочее время и
удлиняет простой при выкладке
- Изменения однонаправлены: для их отката требуется ручное 
вмешательство и продумывание плана отката (что тоже занимает время, 
а сама необходимость отката, как правило, возникает уже во время 
простоя приложения)

Для решения этих проблем и были придуманы инструменты для 
версионирования схемы базы данных, позволяющие формализовать 
изменение схемы базы данных (которое и называется в данном контексте 
миграцией) и автоматизировать две простые операции: применение и откат
этого изменения. Как правило, каждая миграция оформляется в виде файла,
содержащего в себе описание изменений, а инструмент использует эти 
файлы для применения и отката изменений.

Для полной автоматизации работы с приложением миграции должны 
удовлетворять следующим принципам:

- Атомарности (миграция должна либо примениться вся, либо не 
примениться совсем)
- Идемпотнетности (команда применения миграций может выполняться 
1..N раз с одинаковым результатом)
- Детерминированности (результат применения N миграций к конкретной 
базе данных зависит только от того, какая это база данных и всегда 
приводит базу данных к одной и той же структуре)

# Декларативные / исполняемые

В зависимости от инструмента, обеспечивающего разворачивание миграций,
они могут быть декларативными (описанными в виде конфигурационного 
файла) или исполняемыми (описываемыми в виде исполняемого кода).

Как и с конфигурацией, декларативное описание обеспечивает более 
простую автоматическую генерацию и уменьшает возможность выстрелить 
себе в ногу выполнением запрещенных приемов или написанием кода,
подходящего только для специфичной базы данных. Декларативная 
конфигурация дает больший выигрыш в долгосрочной перспективе, однако
непосредственный тип конфигурирования обычно диктуется конечным 
инструментом, которых не так много.

# Атомарность

Миграции в обязательном порядке должны быть атомарными: одна миграция
должна включать в себя ровно одно изменение. Чаще всего возникает 
соблазн сгруппировать изменения в одной миграции:

```yml
- type: addColumn
  column:
    name: alpha
    type: int
  table: journal
- type: addColumn
  column:
    name: beta
    type: timestamp
    default: '0000-00-00 00:00:00'
  table: journal
- type: addColumn
  column:
    name: gamma
    type: int
  table: journal
```

В этом случае может возникнуть следующая ситуация:

- Разработчик успешно тестирует миграцию на локальной машине
- Отправляет ее в репозиторий
- При выкладке конечной базой данных оказывает MySQL в строгом режиме,
который не позволяет указывать нулевые даты, и миграция проваливается
на втором изменении из трех

Если такое произошло, то база данных подвисает в промежуточном 
состоянии между двумя миграциями, и все, ради чего миграции 
внедрялись - воспроизводимость, автоматизируемость, скорость - 
оказывается нивелировано, потому что в этом случае невозможно ни 
повторно применить исправленную миграцию (первое изменение не позволит 
повторно добавить столбец), ни откатить ее, и остается только 
исправлять ситуацию вручную (что прямо противоречит целям внедрения 
миграций). В данном примере ответственность за это лежит на 
разработчике, однако это не значит, что такая ситуация не может 
возникнуть при корректно описанных миграциях: например, нагруженный 
сервер может не успеть вовремя отправить ответ, после чего инструмент 
миграций упадет с ошибкой таймаута посередине миграции, и база данных
опять останется в неконсистентном состоянии.

Возможность подобных ситуаций прямо диктует необходимость соблюдения
принципа **"одна миграция - одно изменение"**.

# Изменение данных и обновление без простоя

Миграции предназначены исключительно для изменения структуры 
приложения, и не должны каким-либо образом изменять данные - это 
нарушает сам принцип версионирования, потому что в этом случае 
результат работы миграций зависит от находящихся в БД на момент 
применения данных, и результат применения не детерминирован. 
Миграции занимаются исключительно структурой БД, изменением данных 
занимается приложение, использующее БД, и в большинстве случаев именно 
через приложение и нужно решать проблемы конфликта схем. На первый 
взгляд может показаться, что, например, при добавлении новых колонок
проще сразу же установить значения по умолчанию, но этот подход не 
учитывает многие крайние случаи. Это можно проиллюстрировать на примере
с приложением, которое хочет добавить новую схему хэширования паролей
пользователей, и смигрировать от одной схемы таблицы пользователей

    -- table users
    id | login | hash
    1  | user  | aaaabbbbccccdddd
    
к другой

    -- table users
    id | login | hash             | hash_algorithm
    1  | user  | aaaabbbbccccdddd | md5
    2  | admin | bbbbccccddddeeee | sha512
    
проще всего в этом случае сделать следующиий набор миграций:

- Добавить столбец `hash_algorithm`
- Заполнить его значением `md5`

Однако в этом случае принцип организации миграций будет нарушен, и
появятся проблемы следующего характера:

- Корректно ли отработает приложение, если пользователь успеет обновить 
пароль после применения миграций, но до обновления приложения?
- Что произойдет, если пользователей слишком много, и запрос окажется
слишком тяжелым, чтобы выполниться до таймаута инструмента миграций?

Правильный подход в данном случае будет следующим:

- Добавить новый столбец `hash_algorithm`
- Добавить в приложение менеджер выбора метода хэширования, который 
будет интерпретировать `null` как `md5`
- Использовать по умолчанию метод хэширования `sha512` для новых хэшей
- При успешном вводе пользователем пароля с хэшем в md5 сохранять 
создавать и сохранять `sha512`-хэш

Такой подход позволяет делать миграционные обновления без какого-либо 
простоя приложения и опасения за происходящее между сменой версии 
приложения и применения миграций. В ряде случаев может оказаться 
необходимым даже создание дублирующей таблицы, в которой приложение
будет дублировать информацию, и удаление старой таблицы в следующем 
релизе.

# Инициализирующие данные

При использовании миграций может возникнуть желание использовать 
миграции для заполнения хранилища начальными данными. Этот механизм 
также идет вразрез с принципами миграций, потому что в этом случае
нельзя обеспечить идемпотентность применения изменений и отката.

Для инициализации данных следуют пользоваться функционалом, получившим
название *Seed* (дословно "посев"), который описывается в 
[соответствующей статье](seed).

# Популярные реализации

## Java

- [Liquibase][liquibase]

## PHP

- [Phinx][phinx]
- [Doctrine Migrations][doctrine-migrations]
- [Yii 2 (встроенный функционал)][yii]
- [Laravel (встроенный функционал)][laravel]
- [CodeIgniter (встроенный функционал)][codeigniter]
- [Phalcon (встроенный функционал)][phalcon]

## Ruby

- [Ruby on Rails (встроенный функционал)][ruby-on-rails]

  [liquibase]: http://www.liquibase.org/
  [phinx]: https://phinx.org/
  [doctrine-migrations]: https://github.com/doctrine/migrations
  [yii]: http://www.yiiframework.com/doc-2.0/guide-db-migrations.html
  [laravel]: https://laravel.com/docs/5.4/migrations
  [codeigniter]: https://www.codeigniter.com/user_guide/libraries/migration.html
  [phalcon]: https://docs.phalconphp.com/en/latest/reference/migrations.html
  [ruby-on-rails]: http://rubyonrails.org/